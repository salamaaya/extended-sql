import subprocess
import sys

def mf_struct(phi):
    result = """
            mf_struct = {}"""
    for f in phi.f_vect:
        if 'min' in f:
            result += f"""
            mf_struct['{f}'] = sys.maxsize"""
        else:
            result += f"""
            mf_struct['{f}'] = 0"""
    return result

def populate(phi):
    '''# TABLE SCAN 1: populate mf-struct with distinct values of grouping attribute (V)'''
    gb = phi.v[0] # group by attribute
    result = """
    mf_structs = {}"""
    result += f"""
    for row in rows:
        if row['{gb}'] not in mf_structs:
            {mf_struct(phi)}
            mf_structs[row['{gb}']] = mf_struct
    """
    return result
    
def gv_scan(phi):
    gb = phi.v[0] # group by attribute
    result = """"""

    # get the aggregate column names
    # e.g., 'count_1_quant' -> we're aggregating on 'quant'
    agg_attrs = {}
    for f in phi.f_vect:
        # parse 'count_1_quant' -> gv='1', attr='quant'
        parts = f.split('_')
        if len(parts) >= 3:
            gv_num = parts[1]
            attr = parts[2]
            agg_attrs[gv_num] = attr

    # group predicates by grouping variable number
    gv_predicates = {}
    for pred in phi.pred_list:
        gv = pred.split('.')[0]
        if gv not in gv_predicates:
            gv_predicates[gv] = []
        gv_predicates[gv].append(pred)

    # generate a scan for each grouping variable
    for gv, preds in gv_predicates.items():
        # get the attribute we're aggregating on for this grouping variable
        agg_attr = agg_attrs.get(gv, 'quant')

        # build conditions, skipping grouping attribute matches
        conditions = []
        for pred in preds:
            # parse: "1.state = 'NY'" -> attribute='state', value='NY'
            parts = pred.split('.', 1)[1]

            # split on equals to get attribute and value
            if ' = ' in parts:
                attr, value = parts.split(' = ', 1)
                attr = attr.strip()
                value = value.strip()

                # skip if this is matching the grouping attribute
                if attr == gb:
                    continue

                # add the condition
                conditions.append(f"row['{attr}'] == {value}")
            if ' > ' in parts:
                attr, value = parts.split(' > ', 1)
                attr = attr.strip()
                value = value.strip()

                # skip if this is matching the grouping attribute
                if attr == gb:
                    continue

                # add the condition
                conditions.append(f"row['{attr}'] > {value}")
            if ' < ' in parts:
                attr, value = parts.split(' < ', 1)
                attr = attr.strip()
                value = value.strip()

                # skip if this is matching the grouping attribute
                if attr == gb:
                    continue

                # add the condition
                conditions.append(f"row['{attr}'] < {value}")
            

        # generate scan only if we have filtering conditions
        if conditions:
            condition_str = ' and '.join(conditions)
            result += f"""
    for row in rows:
        if {condition_str}:
            if row['{gb}'] in mf_structs:
                update(mf_structs[row['{gb}']], '{gv}', row['{agg_attr}'])
        """
    
    return result

def generate(phi, output_file=None):
    tmp = f"""
import os
import psycopg2
import psycopg2.extras
import tabulate
from dotenv import load_dotenv
import sys

# do not edit this file, it is generated by generator.py

def update(mf_struct, gv, cur):
    for f in list(mf_struct.keys()):
        if gv in f:
            if "count" in f:
                mf_struct[f] += 1
            if "max" in f:
                mf_struct[f] = max(mf_struct[f], cur)
            if "min" in f:
                mf_struct[f] = min(mf_struct[f], cur)
            if "avg" in f:
                if "count" not in mf_struct:
                    mf_struct['count'] = 1
                    mf_struct[f] = cur
                else:
                    mf_struct['count'] += 1
                    mf_struct[f] = (mf_struct[f] * (mf_struct['count']-1) + cur) / mf_struct['count']
            if "sum" in f:
                mf_struct[f] += cur

def query():
    load_dotenv()

    user = os.getenv('USER')
    password = os.getenv('PASSWORD')
    dbname = os.getenv('DBNAME')

    conn = psycopg2.connect("dbname="+dbname+" user="+user+" password="+password,
                            cursor_factory=psycopg2.extras.DictCursor)
    cur = conn.cursor()
    cur.execute("SELECT * FROM sales")
    rows = cur.fetchall()
    
    if not rows:
        print("No data found.")
        return ""

    
    _global = []
    {populate(phi)}
    {gv_scan(phi)}
    for mf_struct in list(mf_structs.values()):
        mf_struct.pop('count', None)
    
    #print(mf_structs)

    # output mf_structs (append to _global)
    for key, mf_struct in mf_structs.items():
        row_dict = {{'{phi.v[0]}': key}}
        for f in mf_struct.keys():
            row_dict[f] = mf_struct[f]
        _global.append(row_dict)
    
    return tabulate.tabulate(_global,
                        headers="keys", tablefmt="psql")

def main():
    print(query())
    
if "__main__" == __name__:
    main()
    """

    # write the generated code to a file
    open("_generated.py", "w").write(tmp)
    # execute the generated code

    if output_file:
        result = subprocess.run([sys.executable, "_generated.py"], capture_output=True, text=True)
        with open(output_file, "w+") as f:
            f.write(result.stdout)
            if result.stderr:
                f.write(result.stderr)
    else:
        subprocess.run([sys.executable, "_generated.py"])